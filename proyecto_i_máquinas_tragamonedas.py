# -*- coding: utf-8 -*-
"""Proyecto I - Máquinas Tragamonedas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mkUOutmlcjJz_lzCpiVqboaX4FEBWiC

# **Proyecto I - Máquinas Tragamonedas**
*David Vega Mena*
"""

# Librerias utilizadas.
import numpy as np
import matplotlib.pyplot as plt

def GenY(E, N):
  # Generador de distribuciones discretas con esperanza E
  # tomando los valores de 0 a N.
  # Se generan las uniformes y se ordenan.
  uniformes = np.random.uniform(0, E, N-1)
  uniformes = np.append(uniformes, 0)
  ordenadas = np.sort(uniformes)
  ordenadas = np.append(ordenadas, E)
  # Se calcula la función de densidad acumulada complemento en cada valor de 0 a N-1.
  F=[]
  for i in range(len(ordenadas)-1):
    F.append(ordenadas[i+1]-ordenadas[i])
  F = np.sort(F)[::-1]
  # Se calcula la función de densidad y se devuelve.
  densidad = [1-F[0]]
  for i in range(len(F)-1):
    densidad.append(F[i]-F[i+1])
  # F[-1] pero se agrega la diferencia por temas numéricos.
  densidad.append(1-sum(densidad))
  return densidad

def Esperanza(Distribucion):
  # Calcula la esperanza de una función de distribución discreta.
  E=0
  for i in range(len(Distribucion)):
    E=E+i*Distribucion[i]
  return E

def Varianza(Distribucion):
  E2=0
  for i in range(len(Distribucion)):
    E2=E2+i**2*Distribucion[i]
  return E2-Esperanza(Distribucion)

# Se genera una distribución objetivo aleatoria.
Y = GenY(0.95, 4)
print(Y)
print(Esperanza(Y))
print(Varianza(Y))

def Trayectoria(capitalInicial, tiempoSimulado, Distribucion):
  # Función que genera una trayectoria del capital de una máquina tragamonedas.
  # Tiene como parámetros el capital inicial, el tiempo simulado y la
  # función de densidad de las pérdidas.
  tiempo = 0
  # Se genera un arreglo de tiempo indicando el momento de ocurrencia de los
  # eventos.
  # Se comienza al tiempo 0 con el capital inicial.
  t=[0]
  capital=[capitalInicial]
  # Se suma uno en cada tiempo y luego se resta una v.a. Y de la distribucion.
  while tiempo < tiempoSimulado:
    capital.append(capital[-1]+1)
    t.append(tiempo+1)
    capital.append(capital[-1]-np.random.choice(len(Distribucion), p=Distribucion))
    t.append(tiempo+1)
    # Si la máquina se arruina entonces se detiene la simulación.
    if capital[-1] <= 0:
      return t, capital
    tiempo = tiempo + 1
    # Se regresa el arreglo temporal y de capital para graficar.
  return t, capital

def TrayectoriaSinInterrupcion(capitalInicial, tiempoSimulado, Distribucion):
  # Función que genera una trayectoria del capital de una máquina tragamonedas.
  # Tiene como parámetros el capital inicial, el tiempo simulado y la
  # función de densidad de las pérdidas.
  tiempo = 0
  # Se genera un arreglo de tiempo indicando el momento de ocurrencia de los
  # eventos.
  # Se comienza al tiempo 0 con el capital inicial.
  t=[0]
  capital=[capitalInicial]
  # Se suma uno en cada tiempo y luego se resta una v.a. Y de la distribucion.
  while tiempo < tiempoSimulado:
    capital.append(capital[-1]+1)
    t.append(tiempo+1)
    capital.append(capital[-1]-np.random.choice(len(Distribucion), p=Distribucion))
    t.append(tiempo+1)
    tiempo = tiempo + 1
    # Se regresa el arreglo temporal y de capital para graficar.
  return t, capital

# Ejemplo de trayectoria.
x=Trayectoria(10, 1000, Y)
plt.xlabel("Número de Juego")
plt.ylabel("Capital")
plt.title("Posible Trayectoria de Capital")
plt.plot(x[0], x[1])

# Ejemplo de trayectoria sin interrupcion.
x=TrayectoriaSinInterrupcion(10, 1000, Y)
plt.xlabel("Número de Juego")
plt.ylabel("Capital")
plt.title("Posible Trayectoria de Capital")
plt.plot(x[0], x[1])

def probabilidadRuina(capitalInicial, tiempoSimulado, Distribucion, simulaciones):
  # Función que estima la probabilidad de ruina para un tiempo simulado a través
  # de Monte Carlo para cierto capital inicial y distribucion con cierta
  # cantidad de simulaciones.
  exitos=0
  Simulaciones=[]
  for i in range(simulaciones):
    Simulaciones.append(Trayectoria(capitalInicial, tiempoSimulado, Distribucion))
  for i in Simulaciones:
    # Para cada simulación, si no quebró es un éxito.
    if i[1][-1] > 0:
      exitos=exitos+1
  # Se estima la probabilidad.
  print((simulaciones-exitos)/simulaciones)
  # Se regresa el arreglo de simulaciones.
  return Simulaciones

#Ejemplo de cálculo de probablidad de ruina.
for i in probabilidadRuina(0, 100, [0.5,0.2,0.3], 500):
  plt.plot(i[0],i[1])

plt.title("500 trayectorias simuladas para estimar probabilidad de ruina \n a tiempo 21600 con capital inicial de 0.")
plt.ylabel("Capital")
plt.xlabel("Jugada")

# Calculo de probabilidad de ruina recursivo

def psi(u, n, distribucion):
    if n == 1:
        return 1 - sum(distribucion[:min(u + 1 , len(distribucion))])
    else:
        return (1 - sum(distribucion[:min(u + 1 , len(distribucion))])) + sum(psi(u + 1 - y, n - 1, distribucion) * distribucion[y] for y in range(min(u+1 , len(distribucion))))

# Ejemplo de uso
capital_inicial = 0
tiempo_maximo_ruina = 10
distribucion_Y = [0.5, 0.2, 0.3]

prob_ruina = psi(capital_inicial, tiempo_maximo_ruina, distribucion_Y)
print(prob_ruina)

def distribucionTiempoN(capitalInicial, tiempoSimulado, Distribucion, simulaciones):
  # Función que simula trayectorias a tiempo n.
  Simulaciones=[]
  for i in range(simulaciones):
    Simulaciones.append(TrayectoriaSinInterrupcion(capitalInicial, tiempoSimulado, Distribucion))
  return Simulaciones

for i in distribucionTiempoN(30, 100, Y, 1000):
  plt.plot(i[0],i[1])

plt.title("Trayectorias Simuladas para Estimar Probabilidad de Ruina")
plt.ylabel("Capital")
plt.xlabel("Jugada")

S=distribucionTiempoN(0, 1000, Y, 1000)
capitalFinal=[]
for i in S:
  capitalFinal.append(i[1][-1])
plt.hist(capitalFinal, density=True, bins=30)
capitalFInal = np.array(capitalFinal)
plt.ylabel('Densidades')
plt.xlabel('Valores de capital')
plt.title('Aproximacion a la distribución del capital \n en la partida 1000 con 1000 simulaciones')
print(np.mean(capitalFinal))
print(np.var(capitalFinal))

for i in S:
  plt.plot(i[0],i[1])

plt.title("1000 trayectorias simuladas \n para estimar la distribución de capital a tiempo 1000")
plt.ylabel("Capital")
plt.xlabel("Jugada")

print(Y)

def aproximarDistribucion(capitalInicial, tiempoSimulado, Distribucion, simulaciones):
  premios=len(Distribucion)
  resultados=[0]*premios
  for s in range(simulaciones):
    actual=0
    n=tiempoSimulado
    while actual<premios:
      if actual==premios-1:
        resultados[actual]=resultados[actual]+n
      apariciones=0
      if n>=20:
        apariciones=int(np.random.normal(loc=n*Distribucion[actual], scale=n*Distribucion[actual]*(1-Distribucion[actual]), size=1))
        resultados[actual]=resultados[actual]+apariciones
        n=n-apariciones
        actual=actual+1
      else:
        for i in range(1,n+1):
          if np.random.rand(1)<=Distribucion[actual]:
            apariciones=apariciones+1
        resultados[actual]=resultados[actual]+apariciones
        n=n-apariciones
        actual=actual+1
  return resultados

def scaleDistribucion(distribucion, actual):
    distribucionActual = distribucion.copy()
    acumulada = 0
    for i in range(actual):
        acumulada += distribucion[i]
        distribucionActual[i] = 0
    for i in range(len(distribucionActual)):
        distribucionActual[i] += (distribucionActual[i] / (1 - acumulada)) * acumulada
    return distribucionActual

def aproximar_distribucion(capital_inicial, tiempo_simulado, distribucion, simulaciones):
    premios = len(distribucion)
    distN=[]
    for s in range(simulaciones):
        resultados = [0] * premios
        n = tiempo_simulado
        actual = 0
        while actual<premios:
          distribucionActual=scaleDistribucion(distribucion,actual)
          apariciones = 0
          if actual == premios-1:
              apariciones = n
              resultados[actual] += apariciones
              n -= apariciones
              actual += 1
              break
          if n >= 20:
              apariciones = int(np.random.normal(loc=n * distribucionActual[actual],
                        scale=(n * distribucionActual[actual] *
                         (1 - distribucionActual[actual]))**(1/2),
                          size=1))
          else:
              for i in range(1, n + 1):
                  if np.random.rand(1) <= distribucionActual[actual]:
                        apariciones += 1
          resultados[actual] += apariciones
          n -= apariciones
          actual += 1
        c=0
        for i in range(len(resultados)):
          c=c+i*resultados[i]
        distN.append(capital_inicial+tiempo_simulado-c)
    return distN

Y=[0.43088,0.3251,0.1539,0.0431,0.04701999999999995]

Cn=aproximar_distribucion(0, 21600, Y, 10000)
plt.hist(Cn, density=True, bins=50)
capitalFInal = np.array(Cn)
plt.ylabel('Densidades')
plt.xlabel('Valores de capital')
plt.title('Aproximacion a la distribución del capital \n en la partida 21600 con 1000000 simulaciones')
print(np.mean(Cn))
print(np.var(Cn))